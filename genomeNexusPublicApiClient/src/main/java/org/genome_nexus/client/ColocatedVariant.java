/*
 * Genome Nexus API
 * This page shows how to use HTTP requests to access the Genome Nexus API. There are more high level clients available in Python, R, JavaScript, TypeScript and various other languages as well as a command line client to annotate MAF and VCF. See https://docs.genomenexus.org/api.  Aside from programmatic clients there are web based tools to annotate variants, see https://docs.genomenexus.org/tools.   We currently only provide long-term support for the '/annotation' endpoint. The other endpoints might change.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.genome_nexus.client;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.genome_nexus.JSON;

/**
 * ColocatedVariant
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-26T11:53:02.948968527-05:00[America/New_York]")
public class ColocatedVariant {
  public static final String SERIALIZED_NAME_DB_SNP_ID = "dbSnpId";
  @SerializedName(SERIALIZED_NAME_DB_SNP_ID)
  private String dbSnpId;

  public static final String SERIALIZED_NAME_GNOMAD_NFE_ALLELE = "gnomad_nfe_allele";
  @SerializedName(SERIALIZED_NAME_GNOMAD_NFE_ALLELE)
  private String gnomadNfeAllele;

  public static final String SERIALIZED_NAME_GNOMAD_NFE_MAF = "gnomad_nfe_maf";
  @SerializedName(SERIALIZED_NAME_GNOMAD_NFE_MAF)
  private String gnomadNfeMaf;

  public static final String SERIALIZED_NAME_GNOMAD_AFR_ALLELE = "gnomad_afr_allele";
  @SerializedName(SERIALIZED_NAME_GNOMAD_AFR_ALLELE)
  private String gnomadAfrAllele;

  public static final String SERIALIZED_NAME_GNOMAD_AFR_MAF = "gnomad_afr_maf";
  @SerializedName(SERIALIZED_NAME_GNOMAD_AFR_MAF)
  private String gnomadAfrMaf;

  public static final String SERIALIZED_NAME_GNOMAD_EAS_ALLELE = "gnomad_eas_allele";
  @SerializedName(SERIALIZED_NAME_GNOMAD_EAS_ALLELE)
  private String gnomadEasAllele;

  public static final String SERIALIZED_NAME_GNOMAD_EAS_MAF = "gnomad_eas_maf";
  @SerializedName(SERIALIZED_NAME_GNOMAD_EAS_MAF)
  private String gnomadEasMaf;

  public ColocatedVariant() {
  }

  public ColocatedVariant dbSnpId(String dbSnpId) {
    this.dbSnpId = dbSnpId;
    return this;
  }

   /**
   * Get dbSnpId
   * @return dbSnpId
  **/
  @javax.annotation.Nullable
  public String getDbSnpId() {
    return dbSnpId;
  }

  public void setDbSnpId(String dbSnpId) {
    this.dbSnpId = dbSnpId;
  }


  public ColocatedVariant gnomadNfeAllele(String gnomadNfeAllele) {
    this.gnomadNfeAllele = gnomadNfeAllele;
    return this;
  }

   /**
   * GnomAD Non-Finnish European Allele
   * @return gnomadNfeAllele
  **/
  @javax.annotation.Nonnull
  public String getGnomadNfeAllele() {
    return gnomadNfeAllele;
  }

  public void setGnomadNfeAllele(String gnomadNfeAllele) {
    this.gnomadNfeAllele = gnomadNfeAllele;
  }


  public ColocatedVariant gnomadNfeMaf(String gnomadNfeMaf) {
    this.gnomadNfeMaf = gnomadNfeMaf;
    return this;
  }

   /**
   * GnomAD Non-Finnish European MAF
   * @return gnomadNfeMaf
  **/
  @javax.annotation.Nonnull
  public String getGnomadNfeMaf() {
    return gnomadNfeMaf;
  }

  public void setGnomadNfeMaf(String gnomadNfeMaf) {
    this.gnomadNfeMaf = gnomadNfeMaf;
  }


  public ColocatedVariant gnomadAfrAllele(String gnomadAfrAllele) {
    this.gnomadAfrAllele = gnomadAfrAllele;
    return this;
  }

   /**
   * GnomAD African/African American Allele
   * @return gnomadAfrAllele
  **/
  @javax.annotation.Nonnull
  public String getGnomadAfrAllele() {
    return gnomadAfrAllele;
  }

  public void setGnomadAfrAllele(String gnomadAfrAllele) {
    this.gnomadAfrAllele = gnomadAfrAllele;
  }


  public ColocatedVariant gnomadAfrMaf(String gnomadAfrMaf) {
    this.gnomadAfrMaf = gnomadAfrMaf;
    return this;
  }

   /**
   * GnomAD African/African American MAF
   * @return gnomadAfrMaf
  **/
  @javax.annotation.Nonnull
  public String getGnomadAfrMaf() {
    return gnomadAfrMaf;
  }

  public void setGnomadAfrMaf(String gnomadAfrMaf) {
    this.gnomadAfrMaf = gnomadAfrMaf;
  }


  public ColocatedVariant gnomadEasAllele(String gnomadEasAllele) {
    this.gnomadEasAllele = gnomadEasAllele;
    return this;
  }

   /**
   * GnomAD East Asian Allele
   * @return gnomadEasAllele
  **/
  @javax.annotation.Nonnull
  public String getGnomadEasAllele() {
    return gnomadEasAllele;
  }

  public void setGnomadEasAllele(String gnomadEasAllele) {
    this.gnomadEasAllele = gnomadEasAllele;
  }


  public ColocatedVariant gnomadEasMaf(String gnomadEasMaf) {
    this.gnomadEasMaf = gnomadEasMaf;
    return this;
  }

   /**
   * GnomAD East Asian MAF
   * @return gnomadEasMaf
  **/
  @javax.annotation.Nonnull
  public String getGnomadEasMaf() {
    return gnomadEasMaf;
  }

  public void setGnomadEasMaf(String gnomadEasMaf) {
    this.gnomadEasMaf = gnomadEasMaf;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ColocatedVariant colocatedVariant = (ColocatedVariant) o;
    return Objects.equals(this.dbSnpId, colocatedVariant.dbSnpId) &&
        Objects.equals(this.gnomadNfeAllele, colocatedVariant.gnomadNfeAllele) &&
        Objects.equals(this.gnomadNfeMaf, colocatedVariant.gnomadNfeMaf) &&
        Objects.equals(this.gnomadAfrAllele, colocatedVariant.gnomadAfrAllele) &&
        Objects.equals(this.gnomadAfrMaf, colocatedVariant.gnomadAfrMaf) &&
        Objects.equals(this.gnomadEasAllele, colocatedVariant.gnomadEasAllele) &&
        Objects.equals(this.gnomadEasMaf, colocatedVariant.gnomadEasMaf);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dbSnpId, gnomadNfeAllele, gnomadNfeMaf, gnomadAfrAllele, gnomadAfrMaf, gnomadEasAllele, gnomadEasMaf);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ColocatedVariant {\n");
    sb.append("    dbSnpId: ").append(toIndentedString(dbSnpId)).append("\n");
    sb.append("    gnomadNfeAllele: ").append(toIndentedString(gnomadNfeAllele)).append("\n");
    sb.append("    gnomadNfeMaf: ").append(toIndentedString(gnomadNfeMaf)).append("\n");
    sb.append("    gnomadAfrAllele: ").append(toIndentedString(gnomadAfrAllele)).append("\n");
    sb.append("    gnomadAfrMaf: ").append(toIndentedString(gnomadAfrMaf)).append("\n");
    sb.append("    gnomadEasAllele: ").append(toIndentedString(gnomadEasAllele)).append("\n");
    sb.append("    gnomadEasMaf: ").append(toIndentedString(gnomadEasMaf)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dbSnpId");
    openapiFields.add("gnomad_nfe_allele");
    openapiFields.add("gnomad_nfe_maf");
    openapiFields.add("gnomad_afr_allele");
    openapiFields.add("gnomad_afr_maf");
    openapiFields.add("gnomad_eas_allele");
    openapiFields.add("gnomad_eas_maf");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("gnomad_nfe_allele");
    openapiRequiredFields.add("gnomad_nfe_maf");
    openapiRequiredFields.add("gnomad_afr_allele");
    openapiRequiredFields.add("gnomad_afr_maf");
    openapiRequiredFields.add("gnomad_eas_allele");
    openapiRequiredFields.add("gnomad_eas_maf");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ColocatedVariant
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ColocatedVariant.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ColocatedVariant is not found in the empty JSON string", ColocatedVariant.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ColocatedVariant.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ColocatedVariant` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ColocatedVariant.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("dbSnpId") != null && !jsonObj.get("dbSnpId").isJsonNull()) && !jsonObj.get("dbSnpId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dbSnpId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dbSnpId").toString()));
      }
      if (!jsonObj.get("gnomad_nfe_allele").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gnomad_nfe_allele` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gnomad_nfe_allele").toString()));
      }
      if (!jsonObj.get("gnomad_nfe_maf").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gnomad_nfe_maf` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gnomad_nfe_maf").toString()));
      }
      if (!jsonObj.get("gnomad_afr_allele").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gnomad_afr_allele` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gnomad_afr_allele").toString()));
      }
      if (!jsonObj.get("gnomad_afr_maf").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gnomad_afr_maf` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gnomad_afr_maf").toString()));
      }
      if (!jsonObj.get("gnomad_eas_allele").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gnomad_eas_allele` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gnomad_eas_allele").toString()));
      }
      if (!jsonObj.get("gnomad_eas_maf").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gnomad_eas_maf` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gnomad_eas_maf").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ColocatedVariant.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ColocatedVariant' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ColocatedVariant> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ColocatedVariant.class));

       return (TypeAdapter<T>) new TypeAdapter<ColocatedVariant>() {
           @Override
           public void write(JsonWriter out, ColocatedVariant value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ColocatedVariant read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ColocatedVariant given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ColocatedVariant
  * @throws IOException if the JSON string is invalid with respect to ColocatedVariant
  */
  public static ColocatedVariant fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ColocatedVariant.class);
  }

 /**
  * Convert an instance of ColocatedVariant to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

