/*
 * Genome Nexus API
 * This page shows how to use HTTP requests to access the Genome Nexus API. There are more high level clients available in Python, R, JavaScript, TypeScript and various other languages as well as a command line client to annotate MAF and VCF. See https://docs.genomenexus.org/api.  Aside from programmatic clients there are web based tools to annotate variants, see https://docs.genomenexus.org/tools.   We currently only provide long-term support for the '/annotation' endpoint. The other endpoints might change.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.genome_nexus.client;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.genome_nexus.JSON;

/**
 * AlleleNumber
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-26T11:53:02.948968527-05:00[America/New_York]")
public class AlleleNumber {
  public static final String SERIALIZED_NAME_AN = "an";
  @SerializedName(SERIALIZED_NAME_AN)
  private Integer an;

  public static final String SERIALIZED_NAME_AN_AFR = "an_afr";
  @SerializedName(SERIALIZED_NAME_AN_AFR)
  private Integer anAfr;

  public static final String SERIALIZED_NAME_AN_AMR = "an_amr";
  @SerializedName(SERIALIZED_NAME_AN_AMR)
  private Integer anAmr;

  public static final String SERIALIZED_NAME_AN_ASJ = "an_asj";
  @SerializedName(SERIALIZED_NAME_AN_ASJ)
  private Integer anAsj;

  public static final String SERIALIZED_NAME_AN_EAS = "an_eas";
  @SerializedName(SERIALIZED_NAME_AN_EAS)
  private Integer anEas;

  public static final String SERIALIZED_NAME_AN_FIN = "an_fin";
  @SerializedName(SERIALIZED_NAME_AN_FIN)
  private Integer anFin;

  public static final String SERIALIZED_NAME_AN_NFE = "an_nfe";
  @SerializedName(SERIALIZED_NAME_AN_NFE)
  private Integer anNfe;

  public static final String SERIALIZED_NAME_AN_OTH = "an_oth";
  @SerializedName(SERIALIZED_NAME_AN_OTH)
  private Integer anOth;

  public static final String SERIALIZED_NAME_AN_SAS = "an_sas";
  @SerializedName(SERIALIZED_NAME_AN_SAS)
  private Integer anSas;

  public AlleleNumber() {
  }

  public AlleleNumber an(Integer an) {
    this.an = an;
    return this;
  }

   /**
   * Get an
   * @return an
  **/
  @javax.annotation.Nonnull
  public Integer getAn() {
    return an;
  }

  public void setAn(Integer an) {
    this.an = an;
  }


  public AlleleNumber anAfr(Integer anAfr) {
    this.anAfr = anAfr;
    return this;
  }

   /**
   * Get anAfr
   * @return anAfr
  **/
  @javax.annotation.Nonnull
  public Integer getAnAfr() {
    return anAfr;
  }

  public void setAnAfr(Integer anAfr) {
    this.anAfr = anAfr;
  }


  public AlleleNumber anAmr(Integer anAmr) {
    this.anAmr = anAmr;
    return this;
  }

   /**
   * Get anAmr
   * @return anAmr
  **/
  @javax.annotation.Nonnull
  public Integer getAnAmr() {
    return anAmr;
  }

  public void setAnAmr(Integer anAmr) {
    this.anAmr = anAmr;
  }


  public AlleleNumber anAsj(Integer anAsj) {
    this.anAsj = anAsj;
    return this;
  }

   /**
   * Get anAsj
   * @return anAsj
  **/
  @javax.annotation.Nonnull
  public Integer getAnAsj() {
    return anAsj;
  }

  public void setAnAsj(Integer anAsj) {
    this.anAsj = anAsj;
  }


  public AlleleNumber anEas(Integer anEas) {
    this.anEas = anEas;
    return this;
  }

   /**
   * Get anEas
   * @return anEas
  **/
  @javax.annotation.Nonnull
  public Integer getAnEas() {
    return anEas;
  }

  public void setAnEas(Integer anEas) {
    this.anEas = anEas;
  }


  public AlleleNumber anFin(Integer anFin) {
    this.anFin = anFin;
    return this;
  }

   /**
   * Get anFin
   * @return anFin
  **/
  @javax.annotation.Nonnull
  public Integer getAnFin() {
    return anFin;
  }

  public void setAnFin(Integer anFin) {
    this.anFin = anFin;
  }


  public AlleleNumber anNfe(Integer anNfe) {
    this.anNfe = anNfe;
    return this;
  }

   /**
   * Get anNfe
   * @return anNfe
  **/
  @javax.annotation.Nonnull
  public Integer getAnNfe() {
    return anNfe;
  }

  public void setAnNfe(Integer anNfe) {
    this.anNfe = anNfe;
  }


  public AlleleNumber anOth(Integer anOth) {
    this.anOth = anOth;
    return this;
  }

   /**
   * Get anOth
   * @return anOth
  **/
  @javax.annotation.Nonnull
  public Integer getAnOth() {
    return anOth;
  }

  public void setAnOth(Integer anOth) {
    this.anOth = anOth;
  }


  public AlleleNumber anSas(Integer anSas) {
    this.anSas = anSas;
    return this;
  }

   /**
   * Get anSas
   * @return anSas
  **/
  @javax.annotation.Nonnull
  public Integer getAnSas() {
    return anSas;
  }

  public void setAnSas(Integer anSas) {
    this.anSas = anSas;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AlleleNumber alleleNumber = (AlleleNumber) o;
    return Objects.equals(this.an, alleleNumber.an) &&
        Objects.equals(this.anAfr, alleleNumber.anAfr) &&
        Objects.equals(this.anAmr, alleleNumber.anAmr) &&
        Objects.equals(this.anAsj, alleleNumber.anAsj) &&
        Objects.equals(this.anEas, alleleNumber.anEas) &&
        Objects.equals(this.anFin, alleleNumber.anFin) &&
        Objects.equals(this.anNfe, alleleNumber.anNfe) &&
        Objects.equals(this.anOth, alleleNumber.anOth) &&
        Objects.equals(this.anSas, alleleNumber.anSas);
  }

  @Override
  public int hashCode() {
    return Objects.hash(an, anAfr, anAmr, anAsj, anEas, anFin, anNfe, anOth, anSas);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AlleleNumber {\n");
    sb.append("    an: ").append(toIndentedString(an)).append("\n");
    sb.append("    anAfr: ").append(toIndentedString(anAfr)).append("\n");
    sb.append("    anAmr: ").append(toIndentedString(anAmr)).append("\n");
    sb.append("    anAsj: ").append(toIndentedString(anAsj)).append("\n");
    sb.append("    anEas: ").append(toIndentedString(anEas)).append("\n");
    sb.append("    anFin: ").append(toIndentedString(anFin)).append("\n");
    sb.append("    anNfe: ").append(toIndentedString(anNfe)).append("\n");
    sb.append("    anOth: ").append(toIndentedString(anOth)).append("\n");
    sb.append("    anSas: ").append(toIndentedString(anSas)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("an");
    openapiFields.add("an_afr");
    openapiFields.add("an_amr");
    openapiFields.add("an_asj");
    openapiFields.add("an_eas");
    openapiFields.add("an_fin");
    openapiFields.add("an_nfe");
    openapiFields.add("an_oth");
    openapiFields.add("an_sas");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("an");
    openapiRequiredFields.add("an_afr");
    openapiRequiredFields.add("an_amr");
    openapiRequiredFields.add("an_asj");
    openapiRequiredFields.add("an_eas");
    openapiRequiredFields.add("an_fin");
    openapiRequiredFields.add("an_nfe");
    openapiRequiredFields.add("an_oth");
    openapiRequiredFields.add("an_sas");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to AlleleNumber
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AlleleNumber.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AlleleNumber is not found in the empty JSON string", AlleleNumber.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AlleleNumber.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AlleleNumber` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AlleleNumber.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AlleleNumber.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AlleleNumber' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AlleleNumber> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AlleleNumber.class));

       return (TypeAdapter<T>) new TypeAdapter<AlleleNumber>() {
           @Override
           public void write(JsonWriter out, AlleleNumber value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AlleleNumber read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AlleleNumber given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AlleleNumber
  * @throws IOException if the JSON string is invalid with respect to AlleleNumber
  */
  public static AlleleNumber fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AlleleNumber.class);
  }

 /**
  * Convert an instance of AlleleNumber to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

