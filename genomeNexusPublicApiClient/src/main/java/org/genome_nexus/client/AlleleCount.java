/*
 * Genome Nexus API
 * This page shows how to use HTTP requests to access the Genome Nexus API. There are more high level clients available in Python, R, JavaScript, TypeScript and various other languages as well as a command line client to annotate MAF and VCF. See https://docs.genomenexus.org/api.  Aside from programmatic clients there are web based tools to annotate variants, see https://docs.genomenexus.org/tools.   We currently only provide long-term support for the '/annotation' endpoint. The other endpoints might change.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.genome_nexus.client;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.genome_nexus.JSON;

/**
 * AlleleCount
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-26T11:53:02.948968527-05:00[America/New_York]")
public class AlleleCount {
  public static final String SERIALIZED_NAME_AC = "ac";
  @SerializedName(SERIALIZED_NAME_AC)
  private Integer ac;

  public static final String SERIALIZED_NAME_AC_AFR = "ac_afr";
  @SerializedName(SERIALIZED_NAME_AC_AFR)
  private Integer acAfr;

  public static final String SERIALIZED_NAME_AC_AMR = "ac_amr";
  @SerializedName(SERIALIZED_NAME_AC_AMR)
  private Integer acAmr;

  public static final String SERIALIZED_NAME_AC_ASJ = "ac_asj";
  @SerializedName(SERIALIZED_NAME_AC_ASJ)
  private Integer acAsj;

  public static final String SERIALIZED_NAME_AC_EAS = "ac_eas";
  @SerializedName(SERIALIZED_NAME_AC_EAS)
  private Integer acEas;

  public static final String SERIALIZED_NAME_AC_FIN = "ac_fin";
  @SerializedName(SERIALIZED_NAME_AC_FIN)
  private Integer acFin;

  public static final String SERIALIZED_NAME_AC_NFE = "ac_nfe";
  @SerializedName(SERIALIZED_NAME_AC_NFE)
  private Integer acNfe;

  public static final String SERIALIZED_NAME_AC_OTH = "ac_oth";
  @SerializedName(SERIALIZED_NAME_AC_OTH)
  private Integer acOth;

  public static final String SERIALIZED_NAME_AC_SAS = "ac_sas";
  @SerializedName(SERIALIZED_NAME_AC_SAS)
  private Integer acSas;

  public AlleleCount() {
  }

  public AlleleCount ac(Integer ac) {
    this.ac = ac;
    return this;
  }

   /**
   * Get ac
   * @return ac
  **/
  @javax.annotation.Nonnull
  public Integer getAc() {
    return ac;
  }

  public void setAc(Integer ac) {
    this.ac = ac;
  }


  public AlleleCount acAfr(Integer acAfr) {
    this.acAfr = acAfr;
    return this;
  }

   /**
   * Get acAfr
   * @return acAfr
  **/
  @javax.annotation.Nonnull
  public Integer getAcAfr() {
    return acAfr;
  }

  public void setAcAfr(Integer acAfr) {
    this.acAfr = acAfr;
  }


  public AlleleCount acAmr(Integer acAmr) {
    this.acAmr = acAmr;
    return this;
  }

   /**
   * Get acAmr
   * @return acAmr
  **/
  @javax.annotation.Nonnull
  public Integer getAcAmr() {
    return acAmr;
  }

  public void setAcAmr(Integer acAmr) {
    this.acAmr = acAmr;
  }


  public AlleleCount acAsj(Integer acAsj) {
    this.acAsj = acAsj;
    return this;
  }

   /**
   * Get acAsj
   * @return acAsj
  **/
  @javax.annotation.Nonnull
  public Integer getAcAsj() {
    return acAsj;
  }

  public void setAcAsj(Integer acAsj) {
    this.acAsj = acAsj;
  }


  public AlleleCount acEas(Integer acEas) {
    this.acEas = acEas;
    return this;
  }

   /**
   * Get acEas
   * @return acEas
  **/
  @javax.annotation.Nonnull
  public Integer getAcEas() {
    return acEas;
  }

  public void setAcEas(Integer acEas) {
    this.acEas = acEas;
  }


  public AlleleCount acFin(Integer acFin) {
    this.acFin = acFin;
    return this;
  }

   /**
   * Get acFin
   * @return acFin
  **/
  @javax.annotation.Nonnull
  public Integer getAcFin() {
    return acFin;
  }

  public void setAcFin(Integer acFin) {
    this.acFin = acFin;
  }


  public AlleleCount acNfe(Integer acNfe) {
    this.acNfe = acNfe;
    return this;
  }

   /**
   * Get acNfe
   * @return acNfe
  **/
  @javax.annotation.Nonnull
  public Integer getAcNfe() {
    return acNfe;
  }

  public void setAcNfe(Integer acNfe) {
    this.acNfe = acNfe;
  }


  public AlleleCount acOth(Integer acOth) {
    this.acOth = acOth;
    return this;
  }

   /**
   * Get acOth
   * @return acOth
  **/
  @javax.annotation.Nonnull
  public Integer getAcOth() {
    return acOth;
  }

  public void setAcOth(Integer acOth) {
    this.acOth = acOth;
  }


  public AlleleCount acSas(Integer acSas) {
    this.acSas = acSas;
    return this;
  }

   /**
   * Get acSas
   * @return acSas
  **/
  @javax.annotation.Nonnull
  public Integer getAcSas() {
    return acSas;
  }

  public void setAcSas(Integer acSas) {
    this.acSas = acSas;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AlleleCount alleleCount = (AlleleCount) o;
    return Objects.equals(this.ac, alleleCount.ac) &&
        Objects.equals(this.acAfr, alleleCount.acAfr) &&
        Objects.equals(this.acAmr, alleleCount.acAmr) &&
        Objects.equals(this.acAsj, alleleCount.acAsj) &&
        Objects.equals(this.acEas, alleleCount.acEas) &&
        Objects.equals(this.acFin, alleleCount.acFin) &&
        Objects.equals(this.acNfe, alleleCount.acNfe) &&
        Objects.equals(this.acOth, alleleCount.acOth) &&
        Objects.equals(this.acSas, alleleCount.acSas);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ac, acAfr, acAmr, acAsj, acEas, acFin, acNfe, acOth, acSas);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AlleleCount {\n");
    sb.append("    ac: ").append(toIndentedString(ac)).append("\n");
    sb.append("    acAfr: ").append(toIndentedString(acAfr)).append("\n");
    sb.append("    acAmr: ").append(toIndentedString(acAmr)).append("\n");
    sb.append("    acAsj: ").append(toIndentedString(acAsj)).append("\n");
    sb.append("    acEas: ").append(toIndentedString(acEas)).append("\n");
    sb.append("    acFin: ").append(toIndentedString(acFin)).append("\n");
    sb.append("    acNfe: ").append(toIndentedString(acNfe)).append("\n");
    sb.append("    acOth: ").append(toIndentedString(acOth)).append("\n");
    sb.append("    acSas: ").append(toIndentedString(acSas)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ac");
    openapiFields.add("ac_afr");
    openapiFields.add("ac_amr");
    openapiFields.add("ac_asj");
    openapiFields.add("ac_eas");
    openapiFields.add("ac_fin");
    openapiFields.add("ac_nfe");
    openapiFields.add("ac_oth");
    openapiFields.add("ac_sas");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ac");
    openapiRequiredFields.add("ac_afr");
    openapiRequiredFields.add("ac_amr");
    openapiRequiredFields.add("ac_asj");
    openapiRequiredFields.add("ac_eas");
    openapiRequiredFields.add("ac_fin");
    openapiRequiredFields.add("ac_nfe");
    openapiRequiredFields.add("ac_oth");
    openapiRequiredFields.add("ac_sas");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to AlleleCount
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AlleleCount.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AlleleCount is not found in the empty JSON string", AlleleCount.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AlleleCount.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AlleleCount` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AlleleCount.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AlleleCount.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AlleleCount' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AlleleCount> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AlleleCount.class));

       return (TypeAdapter<T>) new TypeAdapter<AlleleCount>() {
           @Override
           public void write(JsonWriter out, AlleleCount value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AlleleCount read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AlleleCount given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AlleleCount
  * @throws IOException if the JSON string is invalid with respect to AlleleCount
  */
  public static AlleleCount fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AlleleCount.class);
  }

 /**
  * Convert an instance of AlleleCount to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

