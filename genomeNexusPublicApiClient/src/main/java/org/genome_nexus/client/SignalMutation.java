/*
 * Genome Nexus API
 * This page shows how to use HTTP requests to access the Genome Nexus API. There are more high level clients available in Python, R, JavaScript, TypeScript and various other languages as well as a command line client to annotate MAF and VCF. See https://docs.genomenexus.org/api.  Aside from programmatic clients there are web based tools to annotate variants, see https://docs.genomenexus.org/tools.   We currently only provide long-term support for the '/annotation' endpoint. The other endpoints might change.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.genome_nexus.client;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.genome_nexus.client.CountByTumorType;
import org.genome_nexus.client.GeneralPopulationStats;
import org.genome_nexus.client.StatsByTumorType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.genome_nexus.JSON;

/**
 * SignalMutation
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-12-26T11:53:02.948968527-05:00[America/New_York]")
public class SignalMutation {
  public static final String SERIALIZED_NAME_BIALLELIC_COUNTS_BY_TUMOR_TYPE = "biallelicCountsByTumorType";
  @SerializedName(SERIALIZED_NAME_BIALLELIC_COUNTS_BY_TUMOR_TYPE)
  private List<CountByTumorType> biallelicCountsByTumorType;

  public static final String SERIALIZED_NAME_CHROMOSOME = "chromosome";
  @SerializedName(SERIALIZED_NAME_CHROMOSOME)
  private String chromosome;

  public static final String SERIALIZED_NAME_COUNTS_BY_TUMOR_TYPE = "countsByTumorType";
  @SerializedName(SERIALIZED_NAME_COUNTS_BY_TUMOR_TYPE)
  private List<CountByTumorType> countsByTumorType;

  public static final String SERIALIZED_NAME_END_POSITION = "endPosition";
  @SerializedName(SERIALIZED_NAME_END_POSITION)
  private Long endPosition;

  public static final String SERIALIZED_NAME_GENERAL_POPULATION_STATS = "generalPopulationStats";
  @SerializedName(SERIALIZED_NAME_GENERAL_POPULATION_STATS)
  private GeneralPopulationStats generalPopulationStats;

  public static final String SERIALIZED_NAME_HUGO_GENE_SYMBOL = "hugoGeneSymbol";
  @SerializedName(SERIALIZED_NAME_HUGO_GENE_SYMBOL)
  private String hugoGeneSymbol;

  public static final String SERIALIZED_NAME_MSK_EXPER_REVIEW = "mskExperReview";
  @SerializedName(SERIALIZED_NAME_MSK_EXPER_REVIEW)
  private Boolean mskExperReview;

  public static final String SERIALIZED_NAME_MUTATION_STATUS = "mutationStatus";
  @SerializedName(SERIALIZED_NAME_MUTATION_STATUS)
  private String mutationStatus;

  public static final String SERIALIZED_NAME_OVERALL_NUMBER_OF_GERMLINE_HOMOZYGOUS = "overallNumberOfGermlineHomozygous";
  @SerializedName(SERIALIZED_NAME_OVERALL_NUMBER_OF_GERMLINE_HOMOZYGOUS)
  private Integer overallNumberOfGermlineHomozygous;

  public static final String SERIALIZED_NAME_PATHOGENIC = "pathogenic";
  @SerializedName(SERIALIZED_NAME_PATHOGENIC)
  private String pathogenic;

  public static final String SERIALIZED_NAME_PENETRANCE = "penetrance";
  @SerializedName(SERIALIZED_NAME_PENETRANCE)
  private String penetrance;

  public static final String SERIALIZED_NAME_QC_PASS_COUNTS_BY_TUMOR_TYPE = "qcPassCountsByTumorType";
  @SerializedName(SERIALIZED_NAME_QC_PASS_COUNTS_BY_TUMOR_TYPE)
  private List<CountByTumorType> qcPassCountsByTumorType;

  public static final String SERIALIZED_NAME_REFERENCE_ALLELE = "referenceAllele";
  @SerializedName(SERIALIZED_NAME_REFERENCE_ALLELE)
  private String referenceAllele;

  public static final String SERIALIZED_NAME_START_POSITION = "startPosition";
  @SerializedName(SERIALIZED_NAME_START_POSITION)
  private Long startPosition;

  public static final String SERIALIZED_NAME_STATS_BY_TUMOR_TYPE = "statsByTumorType";
  @SerializedName(SERIALIZED_NAME_STATS_BY_TUMOR_TYPE)
  private List<StatsByTumorType> statsByTumorType;

  public static final String SERIALIZED_NAME_VARIANT_ALLELE = "variantAllele";
  @SerializedName(SERIALIZED_NAME_VARIANT_ALLELE)
  private String variantAllele;

  public SignalMutation() {
  }

  public SignalMutation biallelicCountsByTumorType(List<CountByTumorType> biallelicCountsByTumorType) {
    this.biallelicCountsByTumorType = biallelicCountsByTumorType;
    return this;
  }

  public SignalMutation addBiallelicCountsByTumorTypeItem(CountByTumorType biallelicCountsByTumorTypeItem) {
    if (this.biallelicCountsByTumorType == null) {
      this.biallelicCountsByTumorType = new ArrayList<>();
    }
    this.biallelicCountsByTumorType.add(biallelicCountsByTumorTypeItem);
    return this;
  }

   /**
   * Biallelic Counts by Tumor Type
   * @return biallelicCountsByTumorType
  **/
  @javax.annotation.Nullable
  public List<CountByTumorType> getBiallelicCountsByTumorType() {
    return biallelicCountsByTumorType;
  }

  public void setBiallelicCountsByTumorType(List<CountByTumorType> biallelicCountsByTumorType) {
    this.biallelicCountsByTumorType = biallelicCountsByTumorType;
  }


  public SignalMutation chromosome(String chromosome) {
    this.chromosome = chromosome;
    return this;
  }

   /**
   * Chromosome
   * @return chromosome
  **/
  @javax.annotation.Nullable
  public String getChromosome() {
    return chromosome;
  }

  public void setChromosome(String chromosome) {
    this.chromosome = chromosome;
  }


  public SignalMutation countsByTumorType(List<CountByTumorType> countsByTumorType) {
    this.countsByTumorType = countsByTumorType;
    return this;
  }

  public SignalMutation addCountsByTumorTypeItem(CountByTumorType countsByTumorTypeItem) {
    if (this.countsByTumorType == null) {
      this.countsByTumorType = new ArrayList<>();
    }
    this.countsByTumorType.add(countsByTumorTypeItem);
    return this;
  }

   /**
   * Counts by Tumor Type
   * @return countsByTumorType
  **/
  @javax.annotation.Nullable
  public List<CountByTumorType> getCountsByTumorType() {
    return countsByTumorType;
  }

  public void setCountsByTumorType(List<CountByTumorType> countsByTumorType) {
    this.countsByTumorType = countsByTumorType;
  }


  public SignalMutation endPosition(Long endPosition) {
    this.endPosition = endPosition;
    return this;
  }

   /**
   * End Position
   * @return endPosition
  **/
  @javax.annotation.Nullable
  public Long getEndPosition() {
    return endPosition;
  }

  public void setEndPosition(Long endPosition) {
    this.endPosition = endPosition;
  }


  public SignalMutation generalPopulationStats(GeneralPopulationStats generalPopulationStats) {
    this.generalPopulationStats = generalPopulationStats;
    return this;
  }

   /**
   * Get generalPopulationStats
   * @return generalPopulationStats
  **/
  @javax.annotation.Nullable
  public GeneralPopulationStats getGeneralPopulationStats() {
    return generalPopulationStats;
  }

  public void setGeneralPopulationStats(GeneralPopulationStats generalPopulationStats) {
    this.generalPopulationStats = generalPopulationStats;
  }


  public SignalMutation hugoGeneSymbol(String hugoGeneSymbol) {
    this.hugoGeneSymbol = hugoGeneSymbol;
    return this;
  }

   /**
   * Hugo Gene Symbol
   * @return hugoGeneSymbol
  **/
  @javax.annotation.Nullable
  public String getHugoGeneSymbol() {
    return hugoGeneSymbol;
  }

  public void setHugoGeneSymbol(String hugoGeneSymbol) {
    this.hugoGeneSymbol = hugoGeneSymbol;
  }


  public SignalMutation mskExperReview(Boolean mskExperReview) {
    this.mskExperReview = mskExperReview;
    return this;
  }

   /**
   * Msk Expert Review
   * @return mskExperReview
  **/
  @javax.annotation.Nullable
  public Boolean getMskExperReview() {
    return mskExperReview;
  }

  public void setMskExperReview(Boolean mskExperReview) {
    this.mskExperReview = mskExperReview;
  }


  public SignalMutation mutationStatus(String mutationStatus) {
    this.mutationStatus = mutationStatus;
    return this;
  }

   /**
   * Mutation Status
   * @return mutationStatus
  **/
  @javax.annotation.Nullable
  public String getMutationStatus() {
    return mutationStatus;
  }

  public void setMutationStatus(String mutationStatus) {
    this.mutationStatus = mutationStatus;
  }


  public SignalMutation overallNumberOfGermlineHomozygous(Integer overallNumberOfGermlineHomozygous) {
    this.overallNumberOfGermlineHomozygous = overallNumberOfGermlineHomozygous;
    return this;
  }

   /**
   * Get overallNumberOfGermlineHomozygous
   * @return overallNumberOfGermlineHomozygous
  **/
  @javax.annotation.Nullable
  public Integer getOverallNumberOfGermlineHomozygous() {
    return overallNumberOfGermlineHomozygous;
  }

  public void setOverallNumberOfGermlineHomozygous(Integer overallNumberOfGermlineHomozygous) {
    this.overallNumberOfGermlineHomozygous = overallNumberOfGermlineHomozygous;
  }


  public SignalMutation pathogenic(String pathogenic) {
    this.pathogenic = pathogenic;
    return this;
  }

   /**
   * Pathogenic
   * @return pathogenic
  **/
  @javax.annotation.Nullable
  public String getPathogenic() {
    return pathogenic;
  }

  public void setPathogenic(String pathogenic) {
    this.pathogenic = pathogenic;
  }


  public SignalMutation penetrance(String penetrance) {
    this.penetrance = penetrance;
    return this;
  }

   /**
   * Penetrance
   * @return penetrance
  **/
  @javax.annotation.Nullable
  public String getPenetrance() {
    return penetrance;
  }

  public void setPenetrance(String penetrance) {
    this.penetrance = penetrance;
  }


  public SignalMutation qcPassCountsByTumorType(List<CountByTumorType> qcPassCountsByTumorType) {
    this.qcPassCountsByTumorType = qcPassCountsByTumorType;
    return this;
  }

  public SignalMutation addQcPassCountsByTumorTypeItem(CountByTumorType qcPassCountsByTumorTypeItem) {
    if (this.qcPassCountsByTumorType == null) {
      this.qcPassCountsByTumorType = new ArrayList<>();
    }
    this.qcPassCountsByTumorType.add(qcPassCountsByTumorTypeItem);
    return this;
  }

   /**
   * QC Pass Counts by Tumor Type
   * @return qcPassCountsByTumorType
  **/
  @javax.annotation.Nullable
  public List<CountByTumorType> getQcPassCountsByTumorType() {
    return qcPassCountsByTumorType;
  }

  public void setQcPassCountsByTumorType(List<CountByTumorType> qcPassCountsByTumorType) {
    this.qcPassCountsByTumorType = qcPassCountsByTumorType;
  }


  public SignalMutation referenceAllele(String referenceAllele) {
    this.referenceAllele = referenceAllele;
    return this;
  }

   /**
   * Reference Allele
   * @return referenceAllele
  **/
  @javax.annotation.Nullable
  public String getReferenceAllele() {
    return referenceAllele;
  }

  public void setReferenceAllele(String referenceAllele) {
    this.referenceAllele = referenceAllele;
  }


  public SignalMutation startPosition(Long startPosition) {
    this.startPosition = startPosition;
    return this;
  }

   /**
   * Start Position
   * @return startPosition
  **/
  @javax.annotation.Nullable
  public Long getStartPosition() {
    return startPosition;
  }

  public void setStartPosition(Long startPosition) {
    this.startPosition = startPosition;
  }


  public SignalMutation statsByTumorType(List<StatsByTumorType> statsByTumorType) {
    this.statsByTumorType = statsByTumorType;
    return this;
  }

  public SignalMutation addStatsByTumorTypeItem(StatsByTumorType statsByTumorTypeItem) {
    if (this.statsByTumorType == null) {
      this.statsByTumorType = new ArrayList<>();
    }
    this.statsByTumorType.add(statsByTumorTypeItem);
    return this;
  }

   /**
   * Stats By Tumor Type
   * @return statsByTumorType
  **/
  @javax.annotation.Nullable
  public List<StatsByTumorType> getStatsByTumorType() {
    return statsByTumorType;
  }

  public void setStatsByTumorType(List<StatsByTumorType> statsByTumorType) {
    this.statsByTumorType = statsByTumorType;
  }


  public SignalMutation variantAllele(String variantAllele) {
    this.variantAllele = variantAllele;
    return this;
  }

   /**
   * Variant Allele
   * @return variantAllele
  **/
  @javax.annotation.Nullable
  public String getVariantAllele() {
    return variantAllele;
  }

  public void setVariantAllele(String variantAllele) {
    this.variantAllele = variantAllele;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SignalMutation signalMutation = (SignalMutation) o;
    return Objects.equals(this.biallelicCountsByTumorType, signalMutation.biallelicCountsByTumorType) &&
        Objects.equals(this.chromosome, signalMutation.chromosome) &&
        Objects.equals(this.countsByTumorType, signalMutation.countsByTumorType) &&
        Objects.equals(this.endPosition, signalMutation.endPosition) &&
        Objects.equals(this.generalPopulationStats, signalMutation.generalPopulationStats) &&
        Objects.equals(this.hugoGeneSymbol, signalMutation.hugoGeneSymbol) &&
        Objects.equals(this.mskExperReview, signalMutation.mskExperReview) &&
        Objects.equals(this.mutationStatus, signalMutation.mutationStatus) &&
        Objects.equals(this.overallNumberOfGermlineHomozygous, signalMutation.overallNumberOfGermlineHomozygous) &&
        Objects.equals(this.pathogenic, signalMutation.pathogenic) &&
        Objects.equals(this.penetrance, signalMutation.penetrance) &&
        Objects.equals(this.qcPassCountsByTumorType, signalMutation.qcPassCountsByTumorType) &&
        Objects.equals(this.referenceAllele, signalMutation.referenceAllele) &&
        Objects.equals(this.startPosition, signalMutation.startPosition) &&
        Objects.equals(this.statsByTumorType, signalMutation.statsByTumorType) &&
        Objects.equals(this.variantAllele, signalMutation.variantAllele);
  }

  @Override
  public int hashCode() {
    return Objects.hash(biallelicCountsByTumorType, chromosome, countsByTumorType, endPosition, generalPopulationStats, hugoGeneSymbol, mskExperReview, mutationStatus, overallNumberOfGermlineHomozygous, pathogenic, penetrance, qcPassCountsByTumorType, referenceAllele, startPosition, statsByTumorType, variantAllele);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SignalMutation {\n");
    sb.append("    biallelicCountsByTumorType: ").append(toIndentedString(biallelicCountsByTumorType)).append("\n");
    sb.append("    chromosome: ").append(toIndentedString(chromosome)).append("\n");
    sb.append("    countsByTumorType: ").append(toIndentedString(countsByTumorType)).append("\n");
    sb.append("    endPosition: ").append(toIndentedString(endPosition)).append("\n");
    sb.append("    generalPopulationStats: ").append(toIndentedString(generalPopulationStats)).append("\n");
    sb.append("    hugoGeneSymbol: ").append(toIndentedString(hugoGeneSymbol)).append("\n");
    sb.append("    mskExperReview: ").append(toIndentedString(mskExperReview)).append("\n");
    sb.append("    mutationStatus: ").append(toIndentedString(mutationStatus)).append("\n");
    sb.append("    overallNumberOfGermlineHomozygous: ").append(toIndentedString(overallNumberOfGermlineHomozygous)).append("\n");
    sb.append("    pathogenic: ").append(toIndentedString(pathogenic)).append("\n");
    sb.append("    penetrance: ").append(toIndentedString(penetrance)).append("\n");
    sb.append("    qcPassCountsByTumorType: ").append(toIndentedString(qcPassCountsByTumorType)).append("\n");
    sb.append("    referenceAllele: ").append(toIndentedString(referenceAllele)).append("\n");
    sb.append("    startPosition: ").append(toIndentedString(startPosition)).append("\n");
    sb.append("    statsByTumorType: ").append(toIndentedString(statsByTumorType)).append("\n");
    sb.append("    variantAllele: ").append(toIndentedString(variantAllele)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("biallelicCountsByTumorType");
    openapiFields.add("chromosome");
    openapiFields.add("countsByTumorType");
    openapiFields.add("endPosition");
    openapiFields.add("generalPopulationStats");
    openapiFields.add("hugoGeneSymbol");
    openapiFields.add("mskExperReview");
    openapiFields.add("mutationStatus");
    openapiFields.add("overallNumberOfGermlineHomozygous");
    openapiFields.add("pathogenic");
    openapiFields.add("penetrance");
    openapiFields.add("qcPassCountsByTumorType");
    openapiFields.add("referenceAllele");
    openapiFields.add("startPosition");
    openapiFields.add("statsByTumorType");
    openapiFields.add("variantAllele");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to SignalMutation
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SignalMutation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SignalMutation is not found in the empty JSON string", SignalMutation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SignalMutation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SignalMutation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("biallelicCountsByTumorType") != null && !jsonObj.get("biallelicCountsByTumorType").isJsonNull()) {
        JsonArray jsonArraybiallelicCountsByTumorType = jsonObj.getAsJsonArray("biallelicCountsByTumorType");
        if (jsonArraybiallelicCountsByTumorType != null) {
          // ensure the json data is an array
          if (!jsonObj.get("biallelicCountsByTumorType").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `biallelicCountsByTumorType` to be an array in the JSON string but got `%s`", jsonObj.get("biallelicCountsByTumorType").toString()));
          }

          // validate the optional field `biallelicCountsByTumorType` (array)
          for (int i = 0; i < jsonArraybiallelicCountsByTumorType.size(); i++) {
            CountByTumorType.validateJsonElement(jsonArraybiallelicCountsByTumorType.get(i));
          };
        }
      }
      if ((jsonObj.get("chromosome") != null && !jsonObj.get("chromosome").isJsonNull()) && !jsonObj.get("chromosome").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chromosome` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chromosome").toString()));
      }
      if (jsonObj.get("countsByTumorType") != null && !jsonObj.get("countsByTumorType").isJsonNull()) {
        JsonArray jsonArraycountsByTumorType = jsonObj.getAsJsonArray("countsByTumorType");
        if (jsonArraycountsByTumorType != null) {
          // ensure the json data is an array
          if (!jsonObj.get("countsByTumorType").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `countsByTumorType` to be an array in the JSON string but got `%s`", jsonObj.get("countsByTumorType").toString()));
          }

          // validate the optional field `countsByTumorType` (array)
          for (int i = 0; i < jsonArraycountsByTumorType.size(); i++) {
            CountByTumorType.validateJsonElement(jsonArraycountsByTumorType.get(i));
          };
        }
      }
      // validate the optional field `generalPopulationStats`
      if (jsonObj.get("generalPopulationStats") != null && !jsonObj.get("generalPopulationStats").isJsonNull()) {
        GeneralPopulationStats.validateJsonElement(jsonObj.get("generalPopulationStats"));
      }
      if ((jsonObj.get("hugoGeneSymbol") != null && !jsonObj.get("hugoGeneSymbol").isJsonNull()) && !jsonObj.get("hugoGeneSymbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hugoGeneSymbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hugoGeneSymbol").toString()));
      }
      if ((jsonObj.get("mutationStatus") != null && !jsonObj.get("mutationStatus").isJsonNull()) && !jsonObj.get("mutationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mutationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mutationStatus").toString()));
      }
      if ((jsonObj.get("pathogenic") != null && !jsonObj.get("pathogenic").isJsonNull()) && !jsonObj.get("pathogenic").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pathogenic` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pathogenic").toString()));
      }
      if ((jsonObj.get("penetrance") != null && !jsonObj.get("penetrance").isJsonNull()) && !jsonObj.get("penetrance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `penetrance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("penetrance").toString()));
      }
      if (jsonObj.get("qcPassCountsByTumorType") != null && !jsonObj.get("qcPassCountsByTumorType").isJsonNull()) {
        JsonArray jsonArrayqcPassCountsByTumorType = jsonObj.getAsJsonArray("qcPassCountsByTumorType");
        if (jsonArrayqcPassCountsByTumorType != null) {
          // ensure the json data is an array
          if (!jsonObj.get("qcPassCountsByTumorType").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `qcPassCountsByTumorType` to be an array in the JSON string but got `%s`", jsonObj.get("qcPassCountsByTumorType").toString()));
          }

          // validate the optional field `qcPassCountsByTumorType` (array)
          for (int i = 0; i < jsonArrayqcPassCountsByTumorType.size(); i++) {
            CountByTumorType.validateJsonElement(jsonArrayqcPassCountsByTumorType.get(i));
          };
        }
      }
      if ((jsonObj.get("referenceAllele") != null && !jsonObj.get("referenceAllele").isJsonNull()) && !jsonObj.get("referenceAllele").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `referenceAllele` to be a primitive type in the JSON string but got `%s`", jsonObj.get("referenceAllele").toString()));
      }
      if (jsonObj.get("statsByTumorType") != null && !jsonObj.get("statsByTumorType").isJsonNull()) {
        JsonArray jsonArraystatsByTumorType = jsonObj.getAsJsonArray("statsByTumorType");
        if (jsonArraystatsByTumorType != null) {
          // ensure the json data is an array
          if (!jsonObj.get("statsByTumorType").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `statsByTumorType` to be an array in the JSON string but got `%s`", jsonObj.get("statsByTumorType").toString()));
          }

          // validate the optional field `statsByTumorType` (array)
          for (int i = 0; i < jsonArraystatsByTumorType.size(); i++) {
            StatsByTumorType.validateJsonElement(jsonArraystatsByTumorType.get(i));
          };
        }
      }
      if ((jsonObj.get("variantAllele") != null && !jsonObj.get("variantAllele").isJsonNull()) && !jsonObj.get("variantAllele").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `variantAllele` to be a primitive type in the JSON string but got `%s`", jsonObj.get("variantAllele").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SignalMutation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SignalMutation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SignalMutation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SignalMutation.class));

       return (TypeAdapter<T>) new TypeAdapter<SignalMutation>() {
           @Override
           public void write(JsonWriter out, SignalMutation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SignalMutation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of SignalMutation given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of SignalMutation
  * @throws IOException if the JSON string is invalid with respect to SignalMutation
  */
  public static SignalMutation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SignalMutation.class);
  }

 /**
  * Convert an instance of SignalMutation to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

